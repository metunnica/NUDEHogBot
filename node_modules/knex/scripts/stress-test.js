const Bluebird = require('bluebird');

// TODO: setup all DBs with docker
// TODO: setup proxy for closing connections
// TODO: use all dialects

const pg = require('../lib')({
  client: 'pg',
  connection: 'postgres:///knex_test',
  pool: { max: 90 }
});

const mysql = require('../lib')({
  dialect: 'mysql2',
  connection: {
    database: "knex_test",
    user: "root",
    charset: 'utf8'
  },
  pool: { max: 90 }
});

async function main() {
  const pgQueries = [
    ...Array(40).fill(pg('accounts').timeout(100)), // these might eat memory
    ...Array(40).fill(pg('accounts'))               // these might hang indefinitely
  ];

  function killConnectionsPg() {
    return pg.raw(`SELECT pg_terminate_backend(pg_stat_activity.pid) 
      FROM pg_stat_activity
      WHERE pg_stat_activity.datname = 'knex_test' 
        AND pid <> pg_backend_pid()`);
  } 

  async function killConnectionsMyslq() {
    const [rows, colDefs] = await mysql.raw(`SHOW FULL PROCESSLIST`);
    await Promise.all(rows.map(row => mysql.raw(`KILL ${row.Id}`)));
  } 

  const mysqlQueries = [
    ...Array(40).fill(mysql('accounts').timeout(100)),
    ...Array(40).fill(mysql('accounts'))
  ];

  const counters = {
    pgQueries: 0,
    pgResults: 0,
    pgErrors: 0,
    mysqlQueries: 0,
    mysqlResults: 0,
    mysqlErrors: 0
  };

  let lastCounters = {...counters};

  pg.on('query', () => counters.pgQueries += 1);
  pg.on('query-response', () => counters.pgResults += 1);
  pg.on('query-error', () => counters.pgErrors += 1);
  mysql.on('query', () => counters.mysqlQueries += 1);
  mysql.on('query-response', () => counters.mysqlResults += 1);
  mysql.on('query-error', () => counters.mysqlErrors += 1);

  setInterval(() => {
    console.dir({
      markerPerSecond: '-------------------------------------------------------------------------------------------',
      pgQueriesPerSecond: (counters.pgQueries - lastCounters.pgQueries)/2,
      pgResultsPerSecond: (counters.pgResults - lastCounters.pgResults)/2,
      pgErrorsPerSecond: (counters.pgErrors - lastCounters.pgErrors)/2,
      mysqlQueriesPerSecond: (counters.mysqlQueries - lastCounters.mysqlQueries)/2,
      mysqlResultsPerSecond: (counters.mysqlResults - lastCounters.mysqlResults)/2,
      mysqlErrorsPerSecond: (counters.mysqlErrors - lastCounters.mysqlErrors)/2,
    }, {colors: true});

    lastCounters = {...counters};
  }, 2000);

  while(true) {
    try {
      await Promise.all([
        ...pgQueries,
        killConnectionsPg(),
//        ...mysqlQueries,
//        killConnectionsMyslq()
      ]);
    } catch (err) {
      console.log(err);
      // pass on error and try again...
    }
  }
}

main();